# 스코프, 호이스팅

## 스코프(유효범위)란?

스코프란 자바스크립트가 식별자를 검색할 때 사용하는 규칙이며, 식별자가 '유효한' 범위를 나타낸다고 할 수 있다.  
전역 스코프, 지역 스코프로 구분된다.

```javascript
var foo = 'bar';

function() {
    var foo = 'bar2';
    console.log(foo);  // 'bar2'
}

console.log(foo);  // 'bar'
```

위와 같이, 함수 안에서 선언된 'foo'는 함수 안에서만 효력을 발휘한다. 이때, 함수 밖에 선언된 첫번째 foo는 <u>**전역변수**</u>, 함수 안의 foo는 <u>**지역변수**</u>라고 한다.  
스코프는 몇 가지의 특징을 가진다. 이 중에서는 자바스크립트 고유의 특성도 있고, 대부분의 언어들이 공유하는 특성도 존재한다.

---

## 스코프 체인

함수는 중첩되어 쓰일 수 있다. 따라서 스코프도 함수에 따라 중첩될 수 있을 것이다.  
이것은 **스코프가 함수의 중첩에 의해 계층적 구조를 가짐**을 의미한다.

```javascript
var x = "전역변수 x";
var y = "전역변수 y";

function outer() {
	var z = "외부 지역변수 z";

	console.log(x); // "전역변수 x"
	console.log(y); // "전역변수 y"
	console.log(z); // "외부 지역변수 z"

	function inner() {
		var x = "내부 지역변수 x";

		console.log(x); // "내부 지역변수 x"
		console.log(y); // "전역변수 y"
		console.log(z); // "외부 지역변수 z"
	}

	inner();
}

outer();

console.log(x); // "전역변수 x"
console.log(z); // "ReferenceError: z is not defined"(참조 오류)
```

함수가 두 번 중첩되며, 안쪽에 있는 스코프(자식 요소들)의 코드는 상위 스코프(부모 요소들)에서 선언된 변수를 참조할 수 있다. 하지만 그 반대는 불가능하다.  
(<u>상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만, 하위 스코프에서 유효한 변수는 상위 스코프에서 참조할 수 없다.</u>)

변수를 참조할 때 자바스크립트 엔진은 '변수를 참조하는 코드의 스코프'에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. (Dom의 이벤트 버블링과 비슷함.)

---

## 함수 레벨 스코프

자바스크립트는 함수 레벨 스코프를 제공한다. 바꿔 말하면 이는 코드 블록 자체로는 스코프를 만들지 못한다는 사실을 의미한다.

```javascript
var foo = 1;

if (true) {
	var foo = "bar";
}

console.log(foo); // "bar"
```

예제에서, 콘솔에는 "bar"가 출력될 것이다. 위에서 언급했듯 자바스크립트는 블록 레벨에선 스코프를 지원하지 않는다.  
따라서 두번째로 foo가 선언되면, 자바스크립트 엔진은 'var'를 지우고 기존의 foo에 값을 재할당한 것으로 인식한다. 이것은 분명 자바스크립트가 가진 좋지 못한 부분 중 하나일 것이다.

---

## 렉시컬 스코프와 동적 스코프

- 렉시컬(정적) 스코프 : 함수를 어디서 **정의**했는지에 따라 상위 스코프를 결정.
- 동적 스코프 : 함수를 어디서 **호출**했는지에 따라 상위 스코프를 결정.

자바스크립트는 렉시컬 스코프를 따르며, 대부분의 프로그래밍 언어들도 그러하다.

```javascript
var x = 1;

function foo() {
	var x = 10;
	bar();
}

function bar() {
	console.log(x);
}

foo(); // 1
bar(); // 1
```

자바스크립트는 함수가'선언된' 위치를 기준으로 상위 스코프가 결정되는 렉시컬 스코프를 사용한다. 예제에서 'bar'라는 함수가 선언될 때, 상위 스코프는 전역 스코프이다. 하위 스코프에 선언된 변수를 참조할 수는 없으니, bar는 전역변수 'x'를 참조하게 된다.

---

## 호이스팅

다음의 예제를 보자.

```javascript
console.log(foo); // undefined
var foo = "bar";
```

위의 예제에서, 에러가 발생하는 대신 콘솔에는 'undefined'가 출력될 것이다. 위의 코드는 실제로는 아래와 같이 동작하기 때문이다.

```javascript
var foo; // 변수를 선언하고, 초기화하면서 선언된 변수가 '끌어올려짐'
console.log(foo); // undefined
foo = "bar"; // 선언된 변수에 값을 할당
```

이렇게 변수 선언이 해당 스코프의 가장 상위로 '끌어올려지는' 자바스크립트 고유의 동작을 호이스팅(Hoisting) 이라고 한다.  
호이스팅은 소스코드가 실제로 실행되는 런타임 이전에 실행된다. 이는 변수의 '선언' 과 '초기화'가 런타임 이전에 이루어지기 때문이다. 이 때문에 '끌어올려지다(hoist)'라는 이름이 붙은 거고.  
변수만 영향을 받는 것이 아니라, 함수나 클래스 등도 호이스팅의 적용을 받는다.
