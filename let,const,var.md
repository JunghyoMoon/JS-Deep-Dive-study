# var & let, const

## var 사용의 문제점들?

ES6이전, 자바스크립트로 변수를 선언하려면 'var'라는 예약어를 사용해야 했다.  
var로 선언된 변수는 다음과 같은 문제점들을 가지고 있다.

- 함수 레벨 스코프  
  var는 기본적으로 함수 레벨 스코프만을 지원하기 때문에, 함수 외부에서 선언된 변수는 전부 전역 변수가 되어버린다.

  ```javascript
  var i = 10;

  for (var i = 0; i < 5; i++) {
  	console.log(i); // 0 1 2 3 4를 순서대로 출력
  }

  // 의도치 않게 전역변수 i의 값이 변경되게 된다.
  console.log(i); // 5가 출력됨
  ```

  위의 예제와 같이 의도치 않게 전역변수에 영향을 줄 수 있는 문제가 존재한다.

- 변수 중복 선언 허용  
  위의 스코프 관련 예제에서 살펴보았듯, 동일한 식별자를 사용하여 변수를 선언하면 에러를 발생시키지 않고 먼저 선언된 변수에 값을 재할당 해버리는 문제가 있다.

  ```javascript
  var i = 10;
  var i = 1; //  오류를 발생시키는 대신, 원래 선언된 i에 1을 재할당함.
  console.log(i); // 1 출력
  ```

  이는 개발 과정에서 적잖은 문제를 유발할 수 있다. (에러를 띄우지 않으니, 수정이 힘들어짐)

- 변수 호이스팅  
  var로 선언된 변수는 스코프의 상위로 호이스팅되면서 'undefined'로 초기화된다.
  ```javascript
  var foo; // 변수를 선언하고, 초기화하면서 선언된 변수가 '끌어올려짐'
  console.log(foo); // undefined
  var foo = "bar"; // 선언된 변수에 값을 할당
  ```
  변수에 값이 할당되기도 전에 값을 참조할 수 있는 특성 때문에, 이것 역시 프로그램의 흐름상 맞지 않을 뿐더러 오류를 발생시킬수 있는 가능성을 높일 수 있다. 오류 수정도 힘들어질 것이다.

## let의 등장

앞서 설명한 var의 문제들을 해결하기 위해, ES6에서 새로운 변수 키워드인 'let'이 등장하였다. let은 다음과 같은 문제들을 해결할 수 있다.

- **블록 레벨 스코프**  
  let으로 선언된 변수는 <u>블록 레벨 스코프</u>를 따른다. 따라서 전역 변수에 영향을 줄 가능성이 적으며, 식별자 사용의 제약을 덜 수 있다.

  ```javascript
  let i = 10;

  for (let i = 0; i < 5; i++) {
  	console.log(i); // 0 1 2 3 4를 순서대로 출력
  }

  // let은 블록 레벨 스코프를 지원하므로, 처음 선언된 i와 for문 내부의 i는 완전히 분리된다.
  console.log(i); // 10이 출력됨
  ```

- **변수 중복 선언 금지**  
  let으로 선언된 변수는 중복 선언이 금지되어 있다.

  ```javascript
  let i = 10;
  let i = 1; //  let으로 선언된 변수는 중복 선언이 되지 않으므로, 오류를 발생시킬 것이다.
  ```

- **Temporal Dead Zone**  
  var로 선언된 변수는 값을 할당하기도 전에 가져다 쓸 수 있는(참조할 수 있는) 문제가 있었다.  
  하지만 let 으로 선언한 변수는 마치 호이스팅이 되지 않는 것처럼 동작하며 이런 문제를 억제한다.
  ```javascript
  console.log(foo); // 참조 오류를 발생시킴.
  let foo = "bar";
  ```
  var와 똑같이 호이스팅이 발생하긴 하나, <u>let으로 선언된 변수는 값이 할당될 때 까지 참조할 수 없다.</u> let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행되기 때문이다.  
  이렇게 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **Temporal Dead Zone(일시적 사각지대)** 라고 한다.

## const : 변하지 않는 값

변수는 값을 재할당할 수 있다. 하지만 코드를 짜다 보면 <u>변하지 않는 값</u>을 선언해야 할 경우도 분명히 존재한다. ES6에서는 이런 상황을 위해 'const'라는 키워드가 등장했다.

```javascript
let x = 5;
const y = 10;

x = 6;
y = 11; // const로 선언된 변수는 재할당 할 수 없으므로, 오류가 발생하며 실행이 종료될 것임

console.log(x); // 6
console.log(y); // 10?
```

const는 다음과 같은 규칙에 의해 사용해야 한다.

- const 키워드로 선언한 변수는 반드시 **선언과 동시에 초기화(값을 할당)**해야 한다.
- const 키워드는 '상수'를 만들기 때문에, **값을 재할당할 수 없다.**
- 하지만, const키워드에 원시 값이 할당된 것이 아니고, 객체나 배열이 할당되었다면 그 객체나 배열 안에 할당된 값은 변경할 수 있다.

## 결론

var 는 더 이상 사용하지 말 것! let과 const라는 훌륭한 대체제가 있다.

## 그런데 왜 아직 남아있는지?

아직도 한참 전에 만들어진 웹페이지, 웹앱 등 ES6 등장 이전에 만들어진 것들이 수두룩하다.  
또, 아직 'outdated browser'를 이용해야만 하는 사람들도 있을 것이다. 다시 말해, var는 과거와의 연결을 위해 아직까지 남아있는 것이다.
