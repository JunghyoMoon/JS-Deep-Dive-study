# 자바스크립트의 연산자

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행하여 자나의 값을 만든다.  
이때, 연산의 대상은 '피연산자'라고 한다.

```javascript
1 + 2;
// 1, 2는 피연산자, +는 산술 연산자.
```

피연산자는 반드시 값으로 평가될 수 있는 표현식이어야 한다.

## 산술 연산자

피연산자를 대상으로 수학적 계산을 통해 새로운 값을 만든다.

| 이항 산술 연산자 |  의미  |
| :--------------: | :----: |
|        +         |  덧셈  |
|        -         |  뺄셈  |
|        \*        |  곱셈  |
|        /         | 나눗셈 |
|        %         | 나머지 |

이항 산술 연산자는 피연산자의 값을 바꾸는 게 아니라, 두 피연산자의 연산을 통해 새로운 값을 생성하게 된다.

| 단항 산술 연산자 |                    의미                     |
| :--------------: | :-----------------------------------------: |
|        ++        |                   1 증가                    |
|        --        |                   1 감소                    |
|        +         |        효과 없음.. 음양 반전도 불가         |
|        -         | 양수를 음수로, 음수를 양수로 반전한 값 반환 |

단항 산술 연산자는 피연산자의 값을 변경하는 부수 효과가 존재한다. (피연산자의 값을 변경하는 암묵적 할당 적용)  
 숫자 타입이 아닌 피연산자에 +, -를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.

```javascript
var foo = "-1",
	bar = "2",
	sol = "hello";

console.log(-foo); // 1, number
console.log(+bar); // 2, number
console.log(foo); // '-1', number
console.log(bar); // '2', string
console.log(-sol); // NaN
```

\+연산자는 피연산자 중 하나 이상이 문자열일 경우 '문자열 연결'연산자로 동작한다.

```javascript
var foo = "Hello",
	bar = "World",
	num = 1;

console.log(foo + bar); // "HelloWorld"
console.log(foo + num); // "Hello1"
console.log(num + bar); // "1World"
```

이것을 암묵적 타입 변환(타입 강제 변환)이라고 하는데, 아래와 같은 예시들이 존재한다.

```javascript
"1" + 2; // = '12'

1 + true; // = 2
1 + false; // = 1
1 + null; // = 1

//undefined는 숫자로 변환되지 않음.
1 + undefined; // = NaN
```

## 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당하는 연산자이다.  
변수 값을 재할당하는 부수 효과가 있다.  
할당 연산자|예시|동일 표현
:---:|:---:|:---:
=|x = 1|x = 1
+=|x += 1|x = x + 1
-=|x -= 1|x = x - 1
_=|x _= 2|x = x \* 2
/=|x /= 2|x = x / 2
%=|x %= 2|x = x % 2

숫자뿐 아니라, 문자열 연산에도 적용할 수 있다.

```javascript
var array = ["kim", "Lee", "Park"];
array.map((name) => {
	console.log((name += " Chulsu"));
});
// Kim Chulsu, Lee Chulsu, Park Chulsu가 차례로 출력됨.
```

할당문은 값으로 평가되는 표현식이다. 그러므로 '값'으로 표현될 수 있다.

```js
var a, b, c;
a = b = c = 1;
console.log(a, b, c); // 1 1 1 출력
```

## 비교 연산자

불리언 값을 반환하게 된다.  
비교 연산자|의미|설명
:---:|:---:|:---:
==|동등 비교|값이 같음
!=|부동등 비교|값이 다름
===|일치 비교|값과 타입이 같음
!==|불일치 비교|값과 타입이 다름

```js
const x = 10;
const y = "10";

console.log(x == y); // true
console.log(x != y); // false
console.log(x === y); // false
console.log(x !== y); // true
```

일치 연산자는 데이터의 타입까지 같은지 검사한다. 예상치 못한 오류를 방지하기에 좋다.  
(예상치 못한 NaN등을 미연에 방지할 수 있다.)

하지만 숫자 0을 조심해야 한다. 일치 연산자는 -0과 그냥 0을 같은 것으로 인식하기 때문이다.  
NaN도 조심해야 한다. 자기 자신과 일치하지 않는 유일한 값이기 때문.  
이 경우 "Object.is"매서드를 사용하면 좋다. 이는 예측 가능한, 정확한 비교 결과를 반환하기 때문이다.

```js
0 === -0; // true
0 == -0; // true
Object.is(-0, 0); // false

NaN === NaN; // false
NaN == NaN; // false
Object.is(NaN, NaN); // true
```

## 대소 관계 비교 연산자

| 대소 관계 비교 연산자 |  예시  |    설명    |
| :-------------------: | :----: | :--------: |
|           >           | x > y  | x가 y 초과 |
|           <           | x < y  | x가 y 미만 |
|          >=           | x >= y | x가 y 이상 |
|          <=           | x <= y | x가 y 이하 |

## 삼항 조건 연산자

자바스크립트에 딱 하나 있는 삼항 연산자이다. 약식 if 문이라고 생각하면 좋다. 코드를 간결하게 만들 수 있어 유용하다.

```js
const score = 70;
let result;
let result2;

// 삼항 조건 연산자 사용
result = score >= 60 ? "B" : "C";

// 조건문 사용
if (score >= 60) {
	result2 = "B";
} else {
	result2 = "C";
}

console.log(result, result2); //  "B" "B"
```

삼항 조건 연산자가 사용된 표현식은 값으로 평가될 수 있다. 따라서 삼항 조건 연산자 표현식은 값처럼 다른 표현식의 일부가 될 수 있어 유용하게 쓰일 수 있다. (변수에 할당하는 등의 응용이 가능)

## 논리 연산자

and, or, not이라고 생각하면 편하다.
| 논리 연산자 | 예시 | 의미 |
| :---: | :---: | :---: |
| \|\| | x \|\| y | x OR y |
| && | x && y | x AND y|
| ! | !x | NOT x |

논리 부정(!)연산자는 항상 불리언 값을 반환한다. 우측의 피연산자가 불리언이 아닐 경우에도, 불리언 타입으로 암묵적 타입 변환이 수행된다.

```js
!0; // true, 0을 false로 변환
!"Hello"; // false, 문자열을 true로 변환
```

반면 논리합(||), 논리곱(&&) 연산자는 경우에 따라, 어느 한쪽으로 평가될 수 있다. 이를 "단축 평가"라고 하며, 조만간 따로 다루겠다.

```js
"Cat" && "Dog"; // 단축 평가에 의해 "Dog" 반환.
```

## 쉼표 연산자

왼쪽부터 차례로 피연산자를 평가하고, 마지막 피연산자의 평가결과를 반환한다.

```js
let x, y, z;
(x = 1), (y = 2), (z = 3); // 마지막 평가결과인 3이 반환됨.
```

## 그룹 연산자

소괄호로 피연산자를 감싸며, 자신의 피연산자인 표현식을 가장 먼저 평가한다.(연산자의 우선순위 조절 가능) 따라서 그룹 연산자는 연산자들 중 우선순위가 가장 높다.

```js
10 * 2 + 3; // 23
10 * (2 + 3); // 50
```

## typeof 연산자

피연산자의 데이터 타입을 문자열로 반환한다.

```js
typeof true; // "boolean"
typeof "true"; //  "string"
typeof 1; //  "number"
typeof []; //  "object"
typeof {}; //  "object"
typeof Symbol(); //  "symbol"
typeof undefined; //  "undefined"
typeof null; //  "object"
```

이때 null 의 데이터 타입이 "object"로 반환되는 것을 볼 수 있는데, 자바스크립트의 버그 중 하나이다. 어른의 사정으로 아직까지 고쳐지지 않았을 것.  
따라서 null타입을 확인할 때는 "==="연산자를 사용하도록 하자.

## 지수 연산자

좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭제곱하여 반환한다.  
ES7 이전에는 Math 모듈의 pow 메서드를 사용했는데, 지수 연산자의 가독성이 더 좋다.

```js
2 ** 2  // 4
2 ** 1.5  // 2.82842712474619
2 ** 0  // 1
2 ** 2 ** 2  // 16

Math.pow(2, 2);  // 4
Math.pow(2, 1.5);  // 2.82842712474619
Math.pow(2, 0);  // 1

// 음수를 거듭제곱의 밑으로 사용할 경우, 괄호로 묶어야 한다.
-5 ** 2  // 에러 발생
(-5) ** 2  // 25
```

지수 연산자는 이항 연산자 중 우선순위가 가장 높다. (어렵게 생각하지 말고.. 중학교 수학이랑 똑같다.)

## 그 외의 연산자들

| 기타 연산자 |                            설명                             |
| :---------: | :---------------------------------------------------------: |
|     ?.      |                  옵셔널 체이닝 연산자(..?)                  |
|     ??      |                      null 병합 연산자                       |
|   delete    |                        프로퍼티 삭제                        |
|     new     |      생성자 함수를 호출할 때 사용하여 인스턴스를 생성       |
| instanceof  | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 |
|     in      |                     프로퍼티 존재 확인                      |

등장할 때마다 정리하려고 한다.

## 연산자의 부수 효과

대부분의 연산자는 그렇지 않으나, 일부 연산자들( = , ++/--, delete)은 다른 코드에 영향을 주는 부수 효과가 있다.

```js
let x;
x = 1;
console.log(x); // 1
// 위 코드처럼, 할당 연산자는 x변수를 사용하는 다른 코드에 영향을 줄 것이다.(값을 할당)

x++;
console.log(x); // 2
// 역시 값을 증가시키기 때문에 다른 코드에 영향을 줄 것이다.

const y = {
	name: "junghyo",
	age: 27,
};
delete y.age;
console.log(y); // {name: "junghyo"}
// 객체의 프로퍼티를 삭제함으로써, 이 객체를 사용하는 다른 코드에 영향을 줄 것이다.
```

굉장히 간단한 원리이다. 상식적으로 값이 수정되면 변경된 값을 참조하는 다른 코드들도 다른 결과를 뱉어낼 것이기 때문에...

## 연산자 우선순위

우선순위가 높을수록, 그 연산자는 상대적으로 먼저 실행된다.
|우선순위|연산자|
|:---:|:---:|
|1|()|
|2|new(매개변수 존재), . , [](프로퍼티 접근), ()(함수 호출), ?.(옵셔널 체이닝)|
|3|new(매개변수 미존재)|
|4|x++, x--|
|5|!x, +x, -x, ++x, --x, typeof, delete|
|6|\*_(이항 연산자중 가장 높은 우선순위)|
|7|_, /, %|
|8|+, -|
|9|<, <=, >, >=, in, instanceof|
|10|==, !=, ===, !==|
|11|??(null 병합 연산자)|
|12|&&|
|13|\|\||
|14|? ... : ... (삼항 조건 연산자)|
|15|=, +=, -=, \*=, /=, ... (할당 연산자들)|
|16|, (쉼표 연산자)|

## 연산자 결합순위

연산자의 어느 쪽부터 평가를 수행할 것인지를 나타내는 순서이다.
|결합 순서|연산자|
|:---:|:---:|
|좌항 → 우항|+, -, /, %, <, <=, >, >=, &&, \|\|, ., [], (), ??, ?., in, instanceof|
|우항 → 좌항|++, --, 할당 연산자, !x, +x, -x, ++x, --x, typeof, delete, 삼항 조건 연산자|
